# Spring Cloud

## Spring Cloud上下文：Application Context Services

Spring Boot约定一般配置文件的路径和管理应用的endpoints，Spring Cloud
基于此建立并添加一些其他组件需要的特性

### The Bootstrap Application Context


### 服务发现

在任何分布式服务架构中，都需要找到机器物理地址所在地。服务发现可以非常简单
只需要一个配置文件，这个文件包含应用程序所需的所有远程服务的地址。

服务发现对微服务和基于云的应用程序至关重要。
 
 * 为应用团队提供了一种能力。可以快速的对在环境中运行的服务实例数量进行水平伸缩
 * 有助于提高应用程序的弹性，当服务不可用时，则将移除服务可用列表
 
 #### 云中的服务发现
 
 基于云的微服务环境的解决方案机制，这一机制具有以下特点
 
 * **高可用** 服务发现需要能够支持“热”集群环境，如果一个节点不可用，其他节点能接管
 它的工作
 
 * **点对点** 服务发现集群中的节点共享服务实例
 * **负载均衡** 服务发现需要在所有实例之间动态地对请求进行负载均衡
 * **有弹性** 服务发现的客户端应该在本地“缓存”信息，本地缓存允许服务发现功能逐步降级
 * **容错** 服务发现检测出服务实例什么时候不健康，并从可以服务列表中移除
 
 ##### 服务发现架构
 
 1. 服务注册
 2. 服务地址的客户端查找
 3. 信息共享
 4. 健康监测
 
 服务实例启动时，通过一个或多个服务实例发现实例来注册它们可以访问的物理位置、路径和端口
 但每个服务实例以相同的服务ID进行注册，服务ID是唯一标识一组相同服务实例的键。
 
 发现服务请求模型
 
 当服务消费者需要调用一个服务时
 1. 联系发现服务，获取请求的所有服务实例，在服务消费者的机器上缓存本地数据
 2. 每当客户端需要调用该服务时，服务消费者将从缓存中查找位置信息，客户端使用简单
 的负载均衡算法轮询服务
 3. 客户端定期与服务进行联系，并刷新服务实例的缓存。客户端缓存最终一致
 
 风险：
 
 客户端联系服务发现实例以进行刷新和调用时，调用可能会被定向到不健康的服务实例上。
 
 每次服务注册需要30秒的时间，Eureka需要从服务接收3次连续心跳包ping，每次心跳包间隔10秒，
 然后才能使用这个服务。
 
 客户端注册：
 引入eureka依赖
 ```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
```
配置Eureka

```yml
eureka:
  instance:
    prefer-ip-address: true
  client:
    # 向Eureka注册服务
    register-with-eureka: true
    # 拉取注册表的副本
    fetch-registry: true
    # Eureka服务的位置
    service-url: 
      defaultZone: http://localhost:9940/eureka
```
注册服务的ip而不是计算机名

每个通过Eureka注册的服务都有与之相关的两个组件，应用ID和实例ID
应用ID表示一组实例

> 默认情况下Eureka会使用主机名与外界联系，这在服务器的环境中运行良好，但是在docker
>容器中，会以随机生成的主机名启动，并且容器没有DNS记录

Eureka的高可用性：

> 建立多个URL服务并足以实现高可用性。defaultZone只是提供一组服务列表，还需建立多个
>Eureka服务并相互注册，查看官网获取建立Eureka集群的信息

使用OpenFeign调用服务

### Hystrix 客户端的弹性模式

专注在每一层构建冗余，使用集群与负载均衡将基础设施分离到多个位置。

尽管考虑到系统组件的彻底损失，但它们只解决了构建弹性系统的一部分问题。
当服务运行缓慢时，检测服务性能不佳并绕过它是非常困难的：

1. 服务的降级可以以间歇性问题开始，并形成不可逆转的势头。开始于很小的爆发中
知道服务器资源耗尽。
2. 对远程服务的调用通常是同步的，并且不会缩短长时间的运行。
3. 应用程序经常被设计为处理远程资源的彻底故障，而不是部分降级。通常只要服务没有
彻底失败，应用将继续调用这个服务。

#### 客户端弹性模式

在远程服务发生错误或表现不佳时保护远程资源的客户端崩溃。这些模式的目标是让客户端快速失败
而不是消耗数据库连接和线程池之类的宝贵资源，并防止远程服务问题向消费者的上游传播

四种客户端弹性模式：

1. 客户端负载均衡
2. 断路器模式
3. 后备模式
4. 舱壁模式

##### 负载均衡模式

Netflix自带了Ribbon

##### 断路器模式

模仿电路断路器的客户端弹性模式

有了软件断路器，当远程服务被调用时，断路器将监视这个调用。如果调用时间过长，断路器会介入并中断调用。
如果某个资源失败的次数足够多，断路器会采取快速失败，阻止调用失败的远程资源。

##### 后备模式

当远程服务调用失败时，服务消费者将执行替代代码路径。通常会查找另一个数据源或将请求排队

##### 舱壁模式

通过舱壁模式，将远程资源调用分到线程池中，降低一个缓慢的调用拖垮整个应用程序的风险。

#### 为何客户端弹性很重要

断路器在应用程序和远程服务之间充当中间人

1. 快速失败 当远程服务处于降级状态时，应用会快速失败
2. 优雅的失败 通过超时和快速失败
3. 无缝恢复 断路器可以定期检查请求的资源是否重新上线，在没有人为干预情况下，可以
再次访问资源

### Zuul路由

所有的服务网关通过服务网关调用服务。

* 静态路由：服务网关将所有的服务调用放置在单个URL和API路由的后面
* 动态路由：服务网关检查传入的服务请求，根据来自传入请求的数据和服务调用者的身份执行只能路由
* 验证和授权：查看服务调用者是否验证和授权
* 度量数据收集和日志记录：数据通过网关时，使用服务网关收集数据

#### 简介

* 将应用中的所有服务的路由映射到一个URL
* 构建可以对通过网关的请求进行检查和操作的过滤器

> 使用`@EnableZuulServer`不会加载任何Zuul反向代理的过滤器，也不会使用Eureka进行服务发现

### Spring OAuth2

#### 推荐文章

[Spring Cloud Security：Oauth2使用入门](http://www.imooc.com/article/298655)

[Spring Cloud Security：Oauth2结合JWT使用](http://www.imooc.com/article/298656)

[Spring Cloud Security：Oauth2实现单点登录](http://www.imooc.com/article/298880)

[仅需四步，整合SpringSecurity+JWT实现登录认证 ！](http://www.imooc.com/article/299721)

1. 受保护资源
2. 资源持有者
3. 应用程序
4. OAuth2验证服务器

OAuth2是基于令牌的安全框架。
可定义用户组访问那些资源。可以使用不同的授权方案。

* 密码
* 客户端凭据
* 授权码
* 隐式
 
### Spring Cloud Stream

出现的问题：

1. 服务之间的紧密耦合
2. 服务之间的脆弱性
3. 在修改组织服务异增加新的消费者方面不灵活

> 另一种耦合
>处理同一消息的不同版本会出现问题，使用Apache Avro

消息队列的优势：
1. 松耦合
2. 耐久性
3. 可伸缩性
4. 灵活性

#####  松耦合

允许开发人员解耦两个服务，应用只知道它是一条消息而不知道是谁发送的

##### 耐久性

保证即使服务消费者已经关闭，也可以发送消息

##### 可伸缩性

发送者不必等待消息消费者的响应。水平伸缩简单。

##### 灵活性

开发者可以轻松添加新的消费者，不影响原始发送服务。

#### 消息传递架构的缺点

消息传递的架构

1. 消息处理语义

    需要了解应用程序消费有序消息时的行为是什么，以及如果消息没有按顺序消费时
会发生的情况。

2. 消息可见性
    
3. 消息编排
   
   用户事务在不同的时间不按顺序执行。
   
Spring Cloud Stream的四个关键组件

1. 发射器source 发布消息
2. 通道channel 队列的抽象
3. 绑定器binder 与特定的消息平台对话
4. 接收器sink


 
 ## 参考
 [《Spring微服务实战》](https://book.douban.com/subject/30233791/)
 